#include <bits/stdc++.h> 
using namespace std; 

class LRUCache { 
    
	deque<int> dq; 
	unordered_map<int, deque<int>::iterator> m;  //HERE IN MAP WE TAKE ITERATOR BECAUSE WE WANT TO STORE THE ADDRESS OF KEY WHERE IT IS STORED IN DEQUE 
	int size;

public: 
	LRUCache(int); 
	void insert(int); 
	void display(); 
}; 

LRUCache::LRUCache(int n) { size = n; } 


void LRUCache::insert(int x) 
{ // not present in cache 
	if (m.find(x) == m.end()) { // cache is full 
		if (dq.size() == size) { // delete least recently used element 
			int last = dq.back(); 
             dq.pop_back(); 
               m.erase(last); 
		} } 
// present in cache 
	else
		dq.erase(m[x]); //erase() function is used to remove elements from a container from the specified position or range.

	dq.push_front(x); //This function is used to push elements into a deque from the front.
	m[x] = dq.begin();// begin() function is used to return an iterator pointing to the first element of the deque container. 
} 

void LRUCache::display() 
{ 
	for (auto it = dq.begin(); it != dq.end(); it++) 
		cout << (*it) << " "; 
         cout << endl; 
} 
int main() 
{ 
	LRUCache ca(4); 

	ca.insert(1); 
	ca.insert(2); 
	ca.insert(3); 
	ca.insert(1); 
	ca.insert(4); 
	ca.insert(5); 
	ca.display(); 

	return 0; 
} 
//output
//5 4 1 3 


                  | map             | unordered_map
---------------------------------------------------------
Ordering        | increasing  order   | no ordering
                | (by default)        |

Implementation  | Self balancing BST  | Hash Table
                | like Red-Black Tree |  

search time     | log(n)              | O(1) -> Average 
                |                     | O(n) -> Worst Case

Insertion time  | log(n) + Rebalance  | Same as search
                      
Deletion time   | log(n) + Rebalance  | Same as search

