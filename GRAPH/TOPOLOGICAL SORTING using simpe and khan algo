dag pe kam krta hh 
cmputer science 1 -> cmputer science 2 ( phehle 1 ko krna pdega)
dfs + stack use krenge 

Twist: "Stack" ka use. Normal DFS mein hum print pehle karte hain. Yahan hum node ko Stack mein tab daalenge jab uske saare bachon (neighbors) ka kaam khatam ho jaye.

Kyun?

Jo node sabse last mein khatam hoga (Leaf node), wo Stack mein sabse pehle jayega (Bottom).

Jo node sabse shuru mein tha (Start node), wo Stack mein sabse upar aayega (Top).

Jab Stack se nikalenge, to Order sahi milega (Start -> End).

#include <iostream>
#include <vector>
#include <stack> // Stack zaroori hai
using namespace std;

// DFS Function
void findTopoSort(int node, vector<int> &visited, stack<int> &st, vector<vector<int>> &adj) {
    
    visited[node] = 1; // Mark visited
    
    // Pehle neighbors ke paas jao (Unka kaam khatam karo)
    for(int neighbor : adj[node]) {
        if(!visited[neighbor]) {
            findTopoSort(neighbor, visited, st, adj);
        }
    }
    
    // IMP STEP: Wapas aate waqt (Backtracking), node ko Stack mein daalo
    // Matlab: "Mere saare bacchon ka kaam ho gaya, ab meri baari."
    st.push(node);
}

int main() {
    int v = 6;
    vector<vector<int>> adj(v);
    
    // Example DAG: 
    // 5 -> 0, 5 -> 2
    // 4 -> 0, 4 -> 1
    // 2 -> 3
    // 3 -> 1
    
    adj[5] = {0, 2};
    adj[4] = {0, 1};
    adj[2] = {3};
    adj[3] = {1};
    
    vector<int> visited(v, 0);
    stack<int> st; // Result yahan store hoga
    
    // Loop for connected components
    for(int i = 0; i < v; i++) {
        if(!visited[i]) {
            findTopoSort(i, visited, st, adj);
        }
    }
    
    cout << "Topological Sort Order: ";
    // Stack ko khali karo aur print karo
    while(!st.empty()) {
        cout << st.top() << " ";
        st.pop();
    }
    
    return 0;
}




// khan algo 

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
    int v = 6;
    vector<vector<int>> adj(v);
    
    // Graph: 5->0, 5->2, 4->0, 4->1, 2->3, 3->1
    adj[5] = {0, 2};
    adj[4] = {0, 1};
    adj[2] = {3};
    adj[3] = {1};
    
    // Step 1: Calculate Indegree
    vector<int> indegree(v, 0);
    for(int i = 0; i < v; i++) {
        for(int neighbor : adj[i]) {
            indegree[neighbor]++;
        }
    }
    
    // Step 2: Push nodes with 0 Indegree into Queue
    queue<int> q;
    for(int i = 0; i < v; i++) {
        if(indegree[i] == 0) {
            q.push(i);
        }
    }
    
    cout << "Topological Sort (Kahn's Algo): ";
    
    // Step 3: BFS Logic
    while(!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " "; // Print node
        
        // Neighbors ki dependency kam karo
        for(int neighbor : adj[node]) {
            indegree[neighbor]--; // Ek parent hat gaya
            
            // Kya ab ye azad hai?
            if(indegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }
    
    return 0;
}







// A C++ program to print topological 
// sorting of a DAG 


class Graph //GRAPH STRUCTURE 
{ 
    int V;	 
// Pointer to an array containing adjacency listsList 
 list<int> *adj; 
// A function used by topologicalSort 
void topologicalSortUtil(int v, bool visited[], 
   stack<int> &Stack); 
public: 
// Constructor 
	Graph(int V); 

	// function to add an edge to graph 
	void addEdge(int v, int w); 

	// prints a Topological Sort of 
// the complete graph 
	void topologicalSort(); 
}; 

Graph::Graph(int V) 
{ 
    this->V = V; 
    adj = new list<int>[V]; 
} 
  
void Graph::addEdge(int v, int w) 
{ 
// Add w to vâ€™s list. 
    adj[v].push_back(w);  
} 
// A recursive function used by topologicalSort 
void Graph::topologicalSortUtil( int v, bool visited[], stack<int> &Stack) 
{ 
	// Mark the current node as visited. 
	visited[v] = true; 

// Recur for all the vertices 
// adjacent to this vertex 
	list<int>::iterator i; 
	for (i = adj[v].begin(); i != adj[v].end(); ++i) 
		if (!visited[*i]) 
			topologicalSortUtil(*i, visited, Stack); 

	// Push current vertex to stack 
// which stores result 
	Stack.push(v); 
} 

// The function to do Topological Sort. 
// It uses recursive topologicalSortUtil() 
void Graph::topologicalSort() 
{ 
	stack<int> Stack; 

	// Mark all the vertices as not visited 
	bool *visited = new bool[V]; 
	for (int i = 0; i < V; i++) 
		visited[i] = false; 
    for (int i = 0; i < V; i++) 
	if (visited[i] == false) 
		topologicalSortUtil(i, visited, Stack); 

	// Print contents of stack 
	while (Stack.empty() == false) 
	{ 
		cout << Stack.top() << " "; 
		Stack.pop(); 
	} 
} 

// Driver program to test above functions 
int main() 
{ 
	// Create a graph given in the above diagram 
	Graph g(6); 
	g.addEdge(5, 2); 
	g.addEdge(5, 0); 
	g.addEdge(4, 0); 
	g.addEdge(4, 1); 
	g.addEdge(2, 3); 
	g.addEdge(3, 1); 

	cout << "Following is a Topological Sort of the given graph \n"; 
	g.topologicalSort(); 

	return 0; 
} 
